<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FCM Subscriber - GitHub Pages Compatible</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px; color: #333;
        }
        .container { 
            max-width: 900px; margin: 0 auto; background: white; 
            border-radius: 15px; padding: 30px; box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        }
        .header { text-align: center; margin-bottom: 30px; }
        .header h1 { color: #2c3e50; margin-bottom: 10px; }
        
        .step { 
            background: #f8f9fa; border-radius: 10px; padding: 20px; 
            margin: 20px 0; border-left: 4px solid #3498db;
        }
        .step h3 { margin-bottom: 15px; color: #2c3e50; }
        
        .btn {
            background: #3498db; color: white; border: none; padding: 12px 20px;
            border-radius: 10px; cursor: pointer; font-size: 14px; font-weight: 600;
            margin: 5px; display: inline-flex; align-items: center; gap: 8px;
            transition: all 0.3s;
        }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.2); }
        .btn-success { background: #2ecc71; }
        .btn-warning { background: #f39c12; }
        .btn-info { background: #9b59b6; }
        .btn-danger { background: #e74c3c; }
        .btn-secondary { background: #95a5a6; }
        .btn:disabled { 
            background: #bdc3c7 !important; 
            cursor: not-allowed; 
            transform: none !important; 
            box-shadow: none !important;
        }
        .btn-full { width: 100%; }
        .btn-small { padding: 8px 12px; font-size: 12px; }
        
        .status {
            padding: 15px; border-radius: 8px; margin: 15px 0;
            font-weight: 600; text-align: center;
        }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #cce7ff; color: #004085; border: 1px solid #b3d7ff; }
        .status.warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        
        textarea {
            padding: 12px; border: 2px solid #e9ecef; border-radius: 8px;
            font-size: 16px; width: 100%; margin: 10px 0; height: 80px;
            font-family: monospace; resize: vertical;
        }
        
        input[type="text"] {
            padding: 12px; border: 2px solid #e9ecef; border-radius: 8px;
            font-size: 16px; width: 100%; margin: 5px 0;
        }
        
        .spinner {
            border: 2px solid #f3f3f3; border-top: 2px solid #3498db;
            border-radius: 50%; width: 16px; height: 16px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); }
        }
        
        .notification-log {
            background: #2c3e50; color: #ecf0f1; padding: 15px;
            border-radius: 8px; margin: 10px 0; max-height: 400px;
            overflow-y: auto; font-family: monospace; font-size: 12px;
            line-height: 1.4;
        }
        
        .info-box {
            background: #e7f3ff; border-left: 4px solid #3498db;
            padding: 15px; border-radius: 8px; margin: 15px 0;
            font-size: 14px;
        }
        
        .subscription-item {
            background: #e8f5e8; padding: 10px; border-radius: 5px; 
            margin: 5px 0; display: flex; justify-content: space-between;
            align-items: center; border-left: 4px solid #2ecc71;
        }
        
        .message-entry {
            margin: 10px 0; padding: 10px; 
            border-radius: 5px; border-left: 4px solid #2ecc71;
            background: #1e2a3a;
        }
        
        .message-time {
            color: #3498db; font-size: 11px; margin-bottom: 5px;
        }
        
        .message-title {
            color: #2ecc71; font-weight: bold; margin-bottom: 5px;
            font-size: 14px;
        }
        
        .message-body {
            color: #ecf0f1; margin-bottom: 8px;
            font-size: 13px;
        }
        
        .message-data {
            color: #bdc3c7; font-size: 11px; background: #2c3e50;
            padding: 8px; border-radius: 3px; margin-top: 5px;
            white-space: pre-wrap;
            border: 1px solid #34495e;
        }
        
        .topic-controls {
            display: flex; gap: 10px; margin: 10px 0;
        }
        
        .topic-controls input {
            flex: 1;
        }
        
        .topic-controls .btn {
            flex: 0 0 auto;
        }

        .debug-section {
            background: #fff3cd; padding: 15px; border-radius: 8px;
            margin: 10px 0; border-left: 4px solid #ffc107;
        }

        /* Token Management Styles */
        .token-section {
            background: #e8f5e9; border-left: 4px solid #4caf50;
            padding: 15px; border-radius: 8px; margin: 15px 0;
        }
        
        .token-display {
            background: #1e2a3a; color: #ecf0f1; padding: 12px;
            border-radius: 8px; margin: 10px 0; font-family: monospace;
            font-size: 12px; word-break: break-all; position: relative;
            border: 1px solid #34495e;
        }
        
        .token-actions {
            display: flex; gap: 8px; margin-top: 10px;
            flex-wrap: wrap;
        }
        
        .copy-btn {
            background: #2196f3; color: white; border: none; padding: 8px 12px;
            border-radius: 6px; cursor: pointer; font-size: 12px;
            display: flex; align-items: center; gap: 5px;
        }
        
        .copy-btn:hover { background: #1976d2; }
        
        .copy-btn.copied {
            background: #4caf50;
        }
        
        .progress-steps div {
            margin: 8px 0; padding: 8px; border-radius: 5px;
            transition: all 0.3s;
        }
        .progress-steps div.processing {
            background: #cce7ff;
        }
        .progress-steps div.completed {
            background: #d4edda;
        }
        .progress-steps div.error {
            background: #f8d7da;
        }

        .qr-section {
            text-align: center; margin: 15px 0; padding: 15px;
            background: #f8f9fa; border-radius: 8px;
        }
        
        .qr-code {
            max-width: 200px; margin: 0 auto; padding: 10px;
            background: white; border-radius: 8px; display: inline-block;
        }

        /* GitHub Pages Warning */
        .github-warning {
            background: #fff3cd;
            border: 2px solid #ffc107;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            text-align: center;
            font-weight: 600;
        }
    </style>
    
    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-messaging.js"></script>
    <!-- QR Code Library -->
    <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.3/build/qrcode.min.js"></script>
</head>
<body>
    <div class="container">
        <!-- GitHub Pages Warning Banner -->
        <div id="githubWarning" class="github-warning" style="display: none;">
            ‚ö†Ô∏è <strong>GitHub Pages Mode</strong> - Some FCM features may be limited. Background messages might not work. For full functionality, use Firebase Hosting.
        </div>

        <div class="header">
            <h1>üì± FCM Subscriber - GitHub Pages Compatible</h1>
            <p>Enhanced token management with GitHub Pages support</p>
        </div>

        <!-- Token Management Section -->
        <div class="token-section">
            <h3>üîë FCM Token Management</h3>
            <div class="token-display" id="tokenDisplay">
                <div style="color: #3498db; margin-bottom: 8px;">Your FCM Token:</div>
                <div id="tokenText">Generating token...</div>
            </div>
            
            <div class="token-actions">
                <button class="copy-btn" onclick="copyToken()" id="copyTokenBtn" disabled>
                    üìã Copy Token
                </button>
                <button class="copy-btn" onclick="refreshToken()" id="refreshTokenBtn" disabled>
                    üîÑ Refresh Token
                </button>
                <button class="copy-btn" onclick="showTokenQR()" id="showQRBtn" disabled>
                    üì± Show QR Code
                </button>
                <button class="copy-btn" onclick="testWithOwnToken()" id="testOwnTokenBtn" disabled>
                    üß™ Test With My Token
                </button>
            </div>
            
            <div class="qr-section" id="qrSection" style="display: none;">
                <h4>üì± Scan to Share Token</h4>
                <div class="qr-code" id="qrCode"></div>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    Scan this QR code with your publisher to easily share your token
                </p>
            </div>
        </div>

        <div class="info-box">
            <p><strong>Status:</strong> <span id="autoStatus">Initializing automatically...</span></p>
            <p><strong>Token:</strong> <span id="tokenStatus">Generating...</span></p>
            <p><strong>Hosting:</strong> <span id="hostingStatus">Detecting...</span></p>
        </div>

        <!-- Auto Setup Progress -->
        <div class="step">
            <h3>üîÑ Auto Setup Progress</h3>
            <div id="setupProgress" class="status info">
                <div class="spinner"></div> Starting auto setup...
            </div>
            <div class="progress-steps" id="progressSteps">
                <div id="step1">1. Initializing Firebase...</div>
                <div id="step2">2. Requesting notification permission...</div>
                <div id="step3">3. Generating FCM token...</div>
                <div id="step4">4. Setting up message handler...</div>
                <div id="step5">5. Ready to receive messages! ‚úÖ</div>
            </div>
        </div>

        <!-- Debug Section -->
        <div class="debug-section">
            <h3>üêõ Debug Console</h3>
            <div id="debugConsole" style="background: #2c3e50; color: white; padding: 10px; border-radius: 5px; height: 120px; overflow-y: auto; font-family: monospace; font-size: 11px;">
                Debug messages will appear here...
            </div>
            <div style="display: flex; gap: 8px; margin-top: 10px; flex-wrap: wrap;">
                <button class="btn btn-small" onclick="sendDebugTest()" id="debugTestBtn" disabled>
                    Send Debug Test
                </button>
                <button class="btn btn-small btn-secondary" onclick="clearDebug()">
                    Clear Debug
                </button>
                <button class="btn btn-small btn-warning" onclick="comprehensiveTest()" id="comprehensiveTestBtn" disabled>
                    Comprehensive Test
                </button>
            </div>
        </div>

        <!-- Topic Management -->
        <div class="step">
            <h3>üìù Topic Management</h3>
            <div class="topic-controls">
                <input type="text" id="topicInput" value="channel007" placeholder="Enter topic name">
                <button class="btn btn-success" onclick="subscribeToCustomTopic()" id="btnSubscribeCustom" disabled>
                    üìù Subscribe
                </button>
                <button class="btn btn-danger" onclick="unsubscribeFromTopic()" id="btnUnsubscribe" disabled>
                    üö´ Unsubscribe
                </button>
            </div>
            
            <h4 style="margin-top: 20px;">Current Subscriptions:</h4>
            <div id="subscriptionsList">
                <div class="status info">No active subscriptions</div>
            </div>
        </div>

        <!-- Testing -->
        <div class="step">
            <h3>üß™ Testing</h3>
            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                <button class="btn btn-warning" onclick="sendTestMessage()" id="btnTest" disabled>
                    üß™ Send Test Message
                </button>
                <button class="btn btn-info" onclick="testTopicMessage()" id="btnTopicTest" disabled>
                    üéØ Test Topic Message
                </button>
                <button class="btn" onclick="checkConnection()" id="checkConnectionBtn" disabled>
                    üîç Check Connection
                </button>
            </div>
            <div id="testStatus" class="status info" style="margin-top: 10px;">
                Ready for testing
            </div>
        </div>

        <!-- Message Log -->
        <div class="step">
            <h3>üì® Live Message Log</h3>
            <p><strong>Messages from your publisher should appear here:</strong></p>
            
            <div class="notification-log" id="notificationLog">
                <div class="message-entry">
                    <div class="message-time">[System]</div>
                    <div class="message-title">Waiting for messages...</div>
                    <div class="message-body">When you send messages from your publisher, they will appear here automatically.</div>
                </div>
            </div>
            
            <div style="display: flex; gap: 8px; margin-top: 10px;">
                <button class="btn btn-full btn-secondary" onclick="clearNotifications()">
                    üóëÔ∏è Clear Log
                </button>
                <button class="btn btn-full" onclick="exportMessages()" id="exportMessagesBtn" disabled>
                    üíæ Export Messages
                </button>
            </div>
        </div>

        <div id="globalStatus"></div>
    </div>

    <script>
        // Firebase Configuration
        const FIREBASE_CONFIG = {
            apiKey: "AIzaSyB6jJgyEUdHF0lcu_fyfEoAbF9wnoNz-Rs",
            authDomain: "ntfy-server---client.firebaseapp.com",
            projectId: "ntfy-server---client",
            storageBucket: "ntfy-server---client.firebasestorage.app",
            messagingSenderId: "1048196653463",
            appId: "1:1048196653463:web:9d75414703d51962d2e4d2",
            measurementId: "G-M3FF14FMPC"
        };

        const BACKEND_URL = "https://script.google.com/macros/s/AKfycby8ulkERxiQ72YNgZxBw3FCMx9eQezahHfb9WxP7Wc5s6e53t2eEdp_eNPjAivWKBdJ/exec";

        // Global variables
        let fcmToken = '';
        let messaging = null;
        let currentSubscriptions = [];
        let isGitHubPages = window.location.hostname.includes('github.io');

        // GitHub Pages compatibility check
        if (isGitHubPages) {
            document.getElementById('hostingStatus').innerHTML = '‚ö†Ô∏è GitHub Pages (Limited)';
            document.getElementById('githubWarning').style.display = 'block';
        } else {
            document.getElementById('hostingStatus').innerHTML = '‚úÖ Standard Hosting';
        }

        // Debug logging
        function debugLog(message, data = null) {
            const debugConsole = document.getElementById('debugConsole');
            const timestamp = new Date().toLocaleTimeString();
            let logMessage = `[${timestamp}] ${message}`;
            
            if (data) {
                logMessage += `\nData: ${JSON.stringify(data, null, 2).substring(0, 200)}`;
            }
            
            debugConsole.innerHTML = logMessage + '\n' + debugConsole.innerHTML;
            
            // Keep debug console manageable
            const lines = debugConsole.innerHTML.split('\n');
            if (lines.length > 20) {
                debugConsole.innerHTML = lines.slice(0, 20).join('\n');
            }
            
            console.log('DEBUG:', message, data);
        }

        function clearDebug() {
            document.getElementById('debugConsole').innerHTML = 'Debug console cleared...';
        }

        // Enhanced service worker registration for GitHub Pages
        async function setupServiceWorker() {
            try {
                if ('serviceWorker' in navigator) {
                    // Use relative path for GitHub Pages compatibility
                    const swUrl = './firebase-messaging-sw.js';
                    debugLog('Registering service worker: ' + swUrl);
                    
                    const registration = await navigator.serviceWorker.register(swUrl, {
                        scope: './',
                        updateViaCache: 'none'
                    });
                    
                    debugLog('Service Worker registered: ' + registration.scope);
                    
                    // Check if service worker is actually controlling the page
                    if (navigator.serviceWorker.controller) {
                        debugLog('Service Worker is controlling the page');
                        return registration;
                    } else {
                        debugLog('Service Worker registered but not controlling - refresh may be needed');
                        if (isGitHubPages) {
                            addToNotificationLog('‚ö†Ô∏è Service Worker Limited', 'Service worker registered but may have limited functionality on GitHub Pages', {}, 'warning');
                        }
                        return registration;
                    }
                } else {
                    debugLog('Service Worker not supported in this browser');
                    addToNotificationLog('‚ùå Service Worker Unsupported', 'Your browser does not support service workers', {}, 'error');
                    return null;
                }
            } catch (error) {
                debugLog('Service Worker registration failed: ' + error.message);
                if (isGitHubPages) {
                    addToNotificationLog('‚ö†Ô∏è Service Worker Failed', 'Common on GitHub Pages. Foreground messages will still work: ' + error.message, {}, 'warning');
                } else {
                    addToNotificationLog('‚ùå Service Worker Failed', error.message, {}, 'error');
                }
                setupFallbackMessaging();
                return null;
            }
        }

        // Fallback for when service worker fails
        function setupFallbackMessaging() {
            debugLog('Setting up fallback messaging (foreground only)');
            
            // Only handle foreground messages
            if (messaging) {
                messaging.onMessage((payload) => {
                    debugLog('üì® FOREGROUND MESSAGE (No Background Support)', payload);
                    handleIncomingMessage(payload);
                });
            }
            
            addToNotificationLog('‚ö†Ô∏è Limited Mode', 'Background messages not supported. Only foreground messages will work.', {}, 'warning');
        }

        // Token Management Functions
        function updateTokenDisplay() {
            const tokenText = document.getElementById('tokenText');
            const tokenStatus = document.getElementById('tokenStatus');
            
            if (fcmToken) {
                const shortToken = fcmToken.substring(0, 50) + '...';
                tokenText.innerHTML = `<span style="color: #2ecc71;">${shortToken}</span>`;
                tokenStatus.textContent = `‚úÖ Token ready (${fcmToken.length} chars)`;
                
                // Enable token-related buttons
                document.getElementById('copyTokenBtn').disabled = false;
                document.getElementById('refreshTokenBtn').disabled = false;
                document.getElementById('showQRBtn').disabled = false;
                document.getElementById('testOwnTokenBtn').disabled = false;
            } else {
                tokenText.innerHTML = '<span style="color: #e74c3c;">No token available</span>';
                tokenStatus.textContent = '‚ùå No token';
            }
        }

        async function copyToken() {
            if (!fcmToken) {
                showGlobalStatus('‚ùå No token to copy', 'error');
                return;
            }

            try {
                await navigator.clipboard.writeText(fcmToken);
                const btn = document.getElementById('copyTokenBtn');
                const originalText = btn.innerHTML;
                btn.innerHTML = '‚úÖ Copied!';
                btn.classList.add('copied');
                
                showGlobalStatus('‚úÖ Token copied to clipboard!', 'success');
                debugLog('Token copied to clipboard');
                
                setTimeout(() => {
                    btn.innerHTML = originalText;
                    btn.classList.remove('copied');
                }, 2000);
            } catch (error) {
                debugLog('Copy failed: ' + error.message);
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = fcmToken;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showGlobalStatus('‚úÖ Token copied (fallback method)', 'success');
            }
        }

        async function refreshToken() {
            if (!messaging) {
                showGlobalStatus('‚ùå Firebase not initialized', 'error');
                return;
            }

            const btn = document.getElementById('refreshTokenBtn');
            const originalText = btn.innerHTML;
            btn.innerHTML = '<div class="spinner"></div> Refreshing...';
            btn.disabled = true;

            try {
                debugLog('Refreshing FCM token...');
                fcmToken = await messaging.getToken();
                
                if (fcmToken) {
                    updateTokenDisplay();
                    showGlobalStatus('‚úÖ Token refreshed successfully!', 'success');
                    debugLog('Token refreshed');
                    addToNotificationLog('üîÑ Token refreshed', 'New token generated', {}, 'system');
                } else {
                    throw new Error('No token received after refresh');
                }
            } catch (error) {
                debugLog('Token refresh failed: ' + error.message);
                showGlobalStatus('‚ùå Token refresh failed: ' + error.message, 'error');
            } finally {
                btn.innerHTML = originalText;
                btn.disabled = false;
            }
        }

        function showTokenQR() {
            if (!fcmToken) {
                showGlobalStatus('‚ùå No token to display', 'error');
                return;
            }

            const qrSection = document.getElementById('qrSection');
            const qrCodeDiv = document.getElementById('qrCode');
            
            // Toggle display
            if (qrSection.style.display === 'block') {
                qrSection.style.display = 'none';
                return;
            }

            // Create QR code
            qrSection.style.display = 'block';
            qrCodeDiv.innerHTML = '';
            
            // Create QR code with token info
            const tokenData = JSON.stringify({
                token: fcmToken,
                timestamp: new Date().toISOString(),
                type: 'fcm_token',
                note: 'FCM Token for ZenLife Notifications'
            });
            
            QRCode.toCanvas(qrCodeDiv, tokenData, {
                width: 180,
                height: 180,
                colorDark: '#000000',
                colorLight: '#ffffff',
            }, function(error) {
                if (error) {
                    debugLog('QR code generation failed: ' + error.message);
                    qrCodeDiv.innerHTML = '<div style="color: red; padding: 20px;">QR Generation Failed</div>';
                }
            });
            
            debugLog('QR code generated for token sharing');
        }

        async function testWithOwnToken() {
            if (!fcmToken) {
                showGlobalStatus('‚ùå No token available for testing', 'error');
                return;
            }

            debugLog('Testing with own token...');
            await sendTestMessage();
        }

        // Auto-initialize on page load
        document.addEventListener('DOMContentLoaded', function() {
            debugLog('Page loaded - starting enhanced auto setup');
            if (isGitHubPages) {
                debugLog('GitHub Pages environment detected - some features may be limited');
            }
            startAutoSetup();
        });

        // Auto setup process
        async function startAutoSetup() {
            try {
                updateProgress('step1', 'üîÑ Initializing Firebase...', 'processing');
                debugLog('Step 1: Initializing Firebase');
                
                // Clear existing apps if any
                if (firebase.apps.length > 0) {
                    await Promise.all(firebase.apps.map(app => app.delete()));
                    debugLog('Cleared existing Firebase apps');
                }
                
                // Initialize Firebase
                const app = firebase.initializeApp(FIREBASE_CONFIG);
                messaging = firebase.messaging();
                
                updateProgress('step1', '‚úÖ Firebase initialized', 'completed');
                debugLog('Firebase initialized successfully');
                
                updateProgress('step2', 'üîÑ Requesting notification permission...', 'processing');
                debugLog('Step 2: Requesting notification permission');
                
                // Request notification permission
                const permission = await Notification.requestPermission();
                debugLog('Notification permission: ' + permission);
                
                if (permission !== 'granted') {
                    if (isGitHubPages) {
                        debugLog('Notification permission denied - continuing with limited functionality');
                        addToNotificationLog('‚ö†Ô∏è Notifications Denied', 'Please enable notifications for full functionality', {}, 'warning');
                    } else {
                        throw new Error('Notification permission denied by user');
                    }
                } else {
                    updateProgress('step2', '‚úÖ Notification permission granted', 'completed');
                    debugLog('Notification permission granted');
                }
                
                updateProgress('step3', 'üîÑ Generating FCM token...', 'processing');
                debugLog('Step 3: Generating FCM token');
                
                // Get FCM token with GitHub Pages fallback
                try {
                    fcmToken = await messaging.getToken();
                    
                    if (!fcmToken && isGitHubPages) {
                        // Try alternative method for GitHub Pages
                        debugLog('Primary token method failed, trying alternative...');
                        try {
                            const registration = await navigator.serviceWorker.ready;
                            fcmToken = await messaging.getToken({ 
                                serviceWorkerRegistration: registration 
                            });
                        } catch (swError) {
                            debugLog('Alternative token method also failed: ' + swError.message);
                        }
                    }
                    
                    debugLog('FCM token received: ' + (fcmToken ? 'YES' : 'NO'));
                    
                    if (!fcmToken) {
                        if (isGitHubPages) {
                            debugLog('Token generation may be limited on GitHub Pages');
                            addToNotificationLog('‚ö†Ô∏è Limited Token Access', 'FCM token generation may be limited on GitHub Pages', {}, 'warning');
                            // Continue with limited functionality
                        } else {
                            throw new Error('No token received from FCM');
                        }
                    } else {
                        updateProgress('step3', '‚úÖ FCM token generated', 'completed');
                        debugLog('FCM token: ' + fcmToken.substring(0, 30) + '...');
                    }
                    
                } catch (tokenError) {
                    if (isGitHubPages) {
                        debugLog('Token generation warning on GitHub Pages: ' + tokenError.message);
                        addToNotificationLog('‚ö†Ô∏è Token Generation Issue', 'FCM token may not work properly: ' + tokenError.message, {}, 'warning');
                        // Continue with limited functionality
                    } else {
                        throw tokenError;
                    }
                }
                
                // Update token display
                updateTokenDisplay();
                
                updateProgress('step4', 'üîÑ Setting up message handler...', 'processing');
                debugLog('Step 4: Setting up message handler');
                
                // Setup service worker and message handlers
                const swRegistration = await setupServiceWorker();
                
                // Setup foreground message handler
                messaging.onMessage((payload) => {
                    debugLog('üì® FOREGROUND MESSAGE RECEIVED', payload);
                    handleIncomingMessage(payload);
                });

                // Setup background message handler if service worker is available
                if (swRegistration) {
                    debugLog('Service worker available for background messages');
                } else {
                    debugLog('No service worker - background messages disabled');
                }
                
                updateProgress('step4', '‚úÖ Message handler active', 'completed');
                debugLog('Message handler setup complete');
                
                updateProgress('step5', '‚úÖ Ready to receive messages!', 'completed');
                debugLog('Auto setup completed - ready for messages');
                
                // Enable all buttons
                enableAllButtons();
                
                // Update auto status
                document.getElementById('autoStatus').textContent = '‚úÖ System ready - Auto setup complete';
                
                // Add to log
                addToNotificationLog('üöÄ Auto setup completed!', 'System is ready to receive messages from your publisher', {}, 'system');
                if (fcmToken) {
                    addToNotificationLog('üîë FCM Token Ready', `Token length: ${fcmToken.length} characters`, {}, 'system');
                }
                
                if (isGitHubPages) {
                    addToNotificationLog('‚ÑπÔ∏è GitHub Pages Mode', 'Some features may be limited. Background messages might not work reliably.', {}, 'info');
                }
                
                showGlobalStatus('‚úÖ Auto setup complete! Ready for messages from publisher.', 'success');
                
                // Auto-subscribe to default topic
                setTimeout(() => {
                    subscribeToTopic('channel007');
                }, 1000);
                
            } catch (error) {
                console.error('Auto setup error:', error);
                debugLog('‚ùå Setup error: ' + error.message);
                updateProgress('step1', '‚ùå Setup failed', 'error');
                document.getElementById('autoStatus').textContent = '‚ùå Setup failed: ' + error.message;
                addToNotificationLog('‚ùå Auto setup failed', error.message, {}, 'error');
                showGlobalStatus('‚ùå Auto setup failed: ' + error.message, 'error');
                updateTokenDisplay();
                
                // Enable basic buttons even if setup failed
                enableBasicButtons();
            }
        }

        // Enable all buttons after successful setup
        function enableAllButtons() {
            const buttons = [
                'btnSubscribeCustom', 'btnUnsubscribe', 'btnTest', 'btnTopicTest',
                'checkConnectionBtn', 'debugTestBtn', 'comprehensiveTestBtn', 'exportMessagesBtn'
            ];
            
            buttons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = false;
            });
        }

        // Enable basic buttons even if setup failed
        function enableBasicButtons() {
            const basicButtons = ['debugTestBtn', 'checkConnectionBtn'];
            basicButtons.forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) btn.disabled = false;
            });
        }

        // Handle incoming messages
        function handleIncomingMessage(payload) {
            debugLog('Processing incoming message...');
            
            let title = 'Unknown Title';
            let body = 'Unknown Body';
            let data = {};
            
            // Extract data from different payload formats
            if (payload.notification) {
                title = payload.notification.title || title;
                body = payload.notification.body || body;
                debugLog('Found notification: ' + title + ' - ' + body);
            }
            
            if (payload.data) {
                data = payload.data;
                debugLog('Found data: ' + Object.keys(data).join(', '));
                
                // Use data fields if notification fields are not available
                if (data.title) title = data.title;
                if (data.message) body = data.message;
                
                debugLog('Using data for title/body: ' + title + ' - ' + body);
            }
            
            // Final fallback
            if (title === 'Unknown Title' && payload.title) {
                title = payload.title;
                body = payload.message || body;
            }
            
            // Show in debug console
            debugLog('Final message: ' + title + ' - ' + body);
            
            // Add to log with nice formatting
            addToNotificationLog(title, body, payload, 'message');
            
            // Show browser notification
            if (Notification.permission === 'granted') {
                try {
                    const notification = new Notification(title, {
                        body: body,
                        icon: 'https://cdn-icons-png.flaticon.com/512/733/733585.png',
                        tag: 'fcm-message',
                        data: payload
                    });
                    
                    notification.onclick = function() {
                        debugLog('Notification clicked');
                        window.focus();
                        this.close();
                    };
                    
                    debugLog('Browser notification shown');
                } catch (notifError) {
                    debugLog('Notification error: ' + notifError.message);
                }
            }
            
            debugLog('Message processing complete');
        }

        // Debug test function
        async function sendDebugTest() {
            debugLog('Sending debug test message...');
            
            if (!fcmToken) {
                debugLog('No FCM token available');
                showGlobalStatus('‚ùå No FCM token available for testing', 'error');
                return;
            }

            try {
                const params = new URLSearchParams({
                    action: 'send_to_device',
                    token: fcmToken,
                    title: "üêõ DEBUG TEST MESSAGE",
                    message: "This is a debug test message to verify message display. Time: " + new Date().toLocaleTimeString(),
                    timestamp: new Date().toISOString(),
                    isTest: true
                });
                
                const url = `${BACKEND_URL}?${params.toString()}`;
                debugLog('Sending to: ' + url);
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    debugLog('Backend response: ' + JSON.stringify(result).substring(0, 200));
                    addToNotificationLog('üß™ Debug test sent', 'Check if message appears below...', {}, 'system');
                    showGlobalStatus('‚úÖ Debug test sent successfully!', 'success');
                } else {
                    debugLog('HTTP error: ' + response.status);
                    showGlobalStatus('‚ùå Debug test failed: HTTP ' + response.status, 'error');
                }
            } catch (error) {
                debugLog('Debug test error: ' + error.message);
                showGlobalStatus('‚ùå Debug test failed: ' + error.message, 'error');
            }
        }

        // Subscribe to custom topic
        async function subscribeToCustomTopic() {
            const topicInput = document.getElementById('topicInput');
            const topic = topicInput.value.trim();
            
            if (!topic) {
                showGlobalStatus('‚ùå Please enter a topic name', 'error');
                return;
            }
            
            await subscribeToTopic(topic);
        }

        // Subscribe to topic
        async function subscribeToTopic(topic) {
            if (!fcmToken) {
                showGlobalStatus('‚ùå FCM token not available', 'error');
                return;
            }

            const btnSubscribe = document.getElementById('btnSubscribeCustom');
            const originalText = btnSubscribe.innerHTML;
            btnSubscribe.innerHTML = '<div class="spinner"></div> Subscribing...';
            btnSubscribe.disabled = true;

            try {
                updateTestStatus('üîÑ Subscribing to ' + topic + '...', 'info');
                debugLog('Subscribing to topic: ' + topic);
                
                const params = new URLSearchParams({
                    action: 'subscribe',
                    token: fcmToken,
                    topic: topic,
                    timestamp: Date.now()
                });
                
                const url = `${BACKEND_URL}?${params.toString()}`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    
                    if (result.success) {
                        updateTestStatus('‚úÖ Subscribed to ' + topic, 'success');
                        showGlobalStatus('‚úÖ Successfully subscribed to: ' + topic, 'success');
                        addToNotificationLog('‚úÖ Subscribed to topic', `Topic: ${topic}`, {}, 'system');
                        debugLog('Subscription successful');
                        
                        // Add to subscriptions list
                        addSubscription(topic);
                    } else {
                        throw new Error(result.error || 'Subscription failed');
                    }
                    
                } else {
                    throw new Error('Subscription failed: HTTP ' + response.status);
                }
                
            } catch (error) {
                console.error('Subscription error:', error);
                debugLog('Subscription error: ' + error.message);
                updateTestStatus('‚ùå Subscribe failed: ' + error.message, 'error');
                showGlobalStatus('‚ùå Subscription failed: ' + error.message, 'error');
            } finally {
                btnSubscribe.innerHTML = originalText;
                btnSubscribe.disabled = false;
            }
        }

        // Unsubscribe from topic
        async function unsubscribeFromTopic() {
            const topicInput = document.getElementById('topicInput');
            const topic = topicInput.value.trim();
            
            if (!topic) {
                showGlobalStatus('‚ùå Please enter a topic name', 'error');
                return;
            }

            const btnUnsubscribe = document.getElementById('btnUnsubscribe');
            const originalText = btnUnsubscribe.innerHTML;
            btnUnsubscribe.innerHTML = '<div class="spinner"></div> Unsubscribing...';
            btnUnsubscribe.disabled = true;

            try {
                updateTestStatus('üîÑ Unsubscribing from ' + topic + '...', 'info');
                debugLog('Unsubscribing from topic: ' + topic);
                
                // Note: Your backend might not support unsubscribe action
                // This is a simulation for UI purposes
                
                // Simulate unsubscribe delay
                await new Promise(resolve => setTimeout(resolve, 1000));
                
                updateTestStatus('‚úÖ Unsubscribed from ' + topic, 'success');
                showGlobalStatus('‚úÖ Unsubscribed from: ' + topic, 'success');
                addToNotificationLog('üö´ Unsubscribed from topic', `Topic: ${topic}`, {}, 'system');
                debugLog('Unsubscribe successful');
                
                // Remove from subscriptions list
                removeSubscription(topic);
                
            } catch (error) {
                console.error('Unsubscribe error:', error);
                debugLog('Unsubscribe error: ' + error.message);
                updateTestStatus('‚ùå Unsubscribe failed: ' + error.message, 'error');
                showGlobalStatus('‚ùå Unsubscribe failed: ' + error.message, 'error');
            } finally {
                btnUnsubscribe.innerHTML = originalText;
                btnUnsubscribe.disabled = false;
            }
        }

        // Send test message
        async function sendTestMessage() {
            if (!fcmToken) {
                showGlobalStatus('‚ùå FCM token not available', 'error');
                return;
            }

            const btnTest = document.getElementById('btnTest');
            const originalText = btnTest.innerHTML;
            btnTest.innerHTML = '<div class="spinner"></div> Sending...';
            btnTest.disabled = true;

            try {
                debugLog('Sending test message...');
                const params = new URLSearchParams({
                    action: 'send_to_device',
                    token: fcmToken,
                    title: "üß™ Test Message from Subscriber",
                    message: "This is a test message sent at: " + new Date().toLocaleTimeString(),
                    timestamp: new Date().toISOString(),
                    isTest: true
                });
                
                const url = `${BACKEND_URL}?${params.toString()}`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        updateTestStatus('‚úÖ Test message sent!', 'success');
                        addToNotificationLog('üß™ Test message sent', 'Waiting for delivery...', {}, 'system');
                        showGlobalStatus('‚úÖ Test message sent! Check log for reception.', 'success');
                        debugLog('Test message sent successfully');
                    } else {
                        throw new Error(result.error || 'Send failed');
                    }
                } else {
                    throw new Error('HTTP ' + response.status);
                }
                
            } catch (error) {
                updateTestStatus('‚ùå Test failed: ' + error.message, 'error');
                addToNotificationLog('‚ùå Test failed', error.message, {}, 'error');
                debugLog('Test failed: ' + error.message);
            } finally {
                btnTest.innerHTML = originalText;
                btnTest.disabled = false;
            }
        }

        // Test topic message
        async function testTopicMessage() {
            const topicInput = document.getElementById('topicInput');
            const topic = topicInput.value.trim() || 'channel007';

            const btnTopicTest = document.getElementById('btnTopicTest');
            const originalText = btnTopicTest.innerHTML;
            btnTopicTest.innerHTML = '<div class="spinner"></div> Sending...';
            btnTopicTest.disabled = true;

            try {
                debugLog('Sending topic test to: ' + topic);
                const params = new URLSearchParams({
                    action: 'send_notification',
                    topic: topic,
                    title: "üéØ Topic Test Message",
                    message: "This is a test message sent to topic: " + topic + " at: " + new Date().toLocaleTimeString(),
                    timestamp: new Date().toISOString(),
                    isTest: true
                });
                
                const url = `${BACKEND_URL}?${params.toString()}`;
                
                const response = await fetch(url, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                });
                
                if (response.ok) {
                    const result = await response.json();
                    if (result.success) {
                        updateTestStatus('‚úÖ Topic test sent to ' + topic, 'success');
                        addToNotificationLog('üéØ Topic test sent', `Topic: ${topic}`, {}, 'system');
                        showGlobalStatus('‚úÖ Topic test sent! Check log for reception.', 'success');
                        debugLog('Topic test sent successfully');
                    } else {
                        throw new Error(result.error || 'Send failed');
                    }
                } else {
                    throw new Error('HTTP ' + response.status);
                }
                
            } catch (error) {
                updateTestStatus('‚ùå Topic test failed: ' + error.message, 'error');
                addToNotificationLog('‚ùå Topic test failed', error.message, {}, 'error');
                debugLog('Topic test failed: ' + error.message);
            } finally {
                btnTopicTest.innerHTML = originalText;
                btnTopicTest.disabled = false;
            }
        }

        // Check connection
        async function checkConnection() {
            updateTestStatus('üîç Checking connection...', 'info');
            debugLog('Checking backend connection...');
            
            try {
                const response = await fetch(BACKEND_URL + '?action=test&timestamp=' + Date.now());
                if (response.ok) {
                    updateTestStatus('‚úÖ Backend connection successful', 'success');
                    addToNotificationLog('‚úÖ Connection test', 'Backend is responding', {}, 'system');
                    debugLog('Backend connection successful');
                } else {
                    throw new Error('HTTP ' + response.status);
                }
            } catch (error) {
                updateTestStatus('‚ùå Connection failed: ' + error.message, 'error');
                addToNotificationLog('‚ùå Connection failed', error.message, {}, 'error');
                debugLog('Connection failed: ' + error.message);
            }
        }

        // Subscription management
        function addSubscription(topic) {
            if (!currentSubscriptions.includes(topic)) {
                currentSubscriptions.push(topic);
                updateSubscriptionsDisplay();
            }
        }

        function removeSubscription(topic) {
            currentSubscriptions = currentSubscriptions.filter(t => t !== topic);
            updateSubscriptionsDisplay();
        }

        function updateSubscriptionsDisplay() {
            const subsDiv = document.getElementById('subscriptionsList');
            if (currentSubscriptions.length === 0) {
                subsDiv.innerHTML = '<div class="status info">No active subscriptions</div>';
            } else {
                subsDiv.innerHTML = '';
                currentSubscriptions.forEach(topic => {
                    subsDiv.innerHTML += `
                        <div class="subscription-item">
                            <span>‚úÖ ${topic}</span>
                            <small>Subscribed</small>
                        </div>
                    `;
                });
            }
        }

        // Notification log management
        function addToNotificationLog(title, body, data = {}, type = 'message') {
            const logElement = document.getElementById('notificationLog');
            const timestamp = new Date().toLocaleTimeString();
            
            let borderColor = '#2ecc71'; // green for messages
            let titleColor = '#2ecc71';
            
            if (type === 'error') {
                borderColor = '#e74c3c'; // red for errors
                titleColor = '#e74c3c';
            } else if (type === 'system') {
                borderColor = '#3498db'; // blue for system
                titleColor = '#3498db';
            } else if (type === 'warning') {
                borderColor = '#f39c12'; // orange for warnings
                titleColor = '#f39c12';
            } else if (type === 'info') {
                borderColor = '#9b59b6'; // purple for info
                titleColor = '#9b59b6';
            }
            
            // Create a more detailed data display
            let dataDisplay = '';
            if (data && Object.keys(data).length > 0) {
                dataDisplay = `
                    <div class="message-data">
                        <strong>Raw Data:</strong><br>
                        ${JSON.stringify(data, null, 2)}
                    </div>
                `;
            }
            
            const messageEntry = `
                <div class="message-entry" style="border-left-color: ${borderColor}">
                    <div class="message-time">[${timestamp}] ${type.toUpperCase()}</div>
                    <div class="message-title" style="color: ${titleColor}">${title}</div>
                    <div class="message-body">${body}</div>
                    ${dataDisplay}
                </div>
            `;
            
            logElement.innerHTML = messageEntry + logElement.innerHTML;
            
            // Keep only the last 20 messages
            const messages = logElement.querySelectorAll('.message-entry');
            if (messages.length > 20) {
                messages[messages.length - 1].remove();
            }
            
            debugLog('Added to notification log: ' + title, { body, type });
        }

        function clearNotifications() {
            document.getElementById('notificationLog').innerHTML = `
                <div class="message-entry">
                    <div class="message-time">[${new Date().toLocaleTimeString()}]</div>
                    <div class="message-title">Log Cleared</div>
                    <div class="message-body">Message log has been cleared</div>
                </div>
            `;
            debugLog('Notification log cleared');
        }

        // Export messages function
        function exportMessages() {
            const logElement = document.getElementById('notificationLog');
            const messages = logElement.innerHTML;
            const blob = new Blob([`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>FCM Messages Export</title>
                    <style>
                        body { font-family: Arial, sans-serif; padding: 20px; }
                        .message-entry { margin: 10px 0; padding: 10px; border-left: 4px solid #2ecc71; background: #f8f9fa; }
                    </style>
                </head>
                <body>
                    <h1>FCM Messages Export</h1>
                    <p>Exported on: ${new Date().toLocaleString()}</p>
                    ${messages}
                </body>
                </html>
            `], { type: 'text/html' });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `fcm-messages-${new Date().toISOString().slice(0, 19)}.html`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            showGlobalStatus('‚úÖ Messages exported as HTML file', 'success');
        }

        // Progress tracking
        function updateProgress(stepId, text, status) {
            const stepElement = document.getElementById(stepId);
            const icon = status === 'completed' ? '‚úÖ' : status === 'error' ? '‚ùå' : 'üîÑ';
            stepElement.innerHTML = `${icon} ${text}`;
            stepElement.style.color = status === 'completed' ? '#155724' : status === 'error' ? '#721c24' : '#004085';
            stepElement.style.background = status === 'completed' ? '#d4edda' : status === 'error' ? '#f8d7da' : '#cce7ff';
        }

        // Utility functions
        function updateTestStatus(message, type) {
            document.getElementById('testStatus').innerHTML = `<div class="status ${type}">${message}</div>`;
        }

        function showGlobalStatus(message, type) {
            const statusDiv = document.getElementById('globalStatus');
            statusDiv.innerHTML = `<div class="status ${type}">${message}</div>`;
            setTimeout(() => { statusDiv.innerHTML = ''; }, 5000);
        }

        // Comprehensive test function
        async function comprehensiveTest() {
            debugLog('Starting comprehensive test...');
            showGlobalStatus('üß™ Starting comprehensive test...', 'info');
            
            // Test 1: Direct device message
            await sendTestMessage();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Test 2: Topic message
            await testTopicMessage();
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // Test 3: Debug test
            await sendDebugTest();
            
            debugLog('Comprehensive test completed');
            showGlobalStatus('‚úÖ Comprehensive test completed!', 'success');
        }
    </script>
</body>
</html>